use roxmltree::Document;
use std::collections::BTreeMap;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

#[derive(Debug, Clone)]
struct IconData {
    name: String,
    category: String,
    view_box: String,
    path_data: String,
    comment: String,
    file_path: String,
}

fn snake_case_to_upper(s: &str) -> String {
    let mut result = s.to_uppercase().replace('-', "_");
    // Ensure identifiers don't start with a number
    if result.chars().next().is_some_and(|c| c.is_ascii_digit()) {
        result = format!("ICON_{}", result);
    }
    result
}

fn process_svg_file(path: &Path) -> Result<IconData, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(path)?;
    
    // Extract the comment (it's between <!-- and -->)
    let comment = if let Some(start) = content.find("<!--") {
        if let Some(end) = content.find("-->") {
            content[start + 4..end].trim().to_string()
        } else {
            String::new()
        }
    } else {
        String::new()
    };
    
    let doc = Document::parse(&content)?;
    
    let root = doc.root_element();
    let svg = root
        .descendants()
        .find(|n| n.tag_name().name() == "svg")
        .ok_or("No SVG element found")?;
    
    let view_box = svg
        .attribute("viewBox")
        .ok_or("No viewBox attribute")?
        .to_string();
    
    let path_elem = svg
        .descendants()
        .find(|n| n.tag_name().name() == "path")
        .ok_or("No path element found")?;
    
    let path_data = path_elem
        .attribute("d")
        .ok_or("No d attribute in path")?
        .to_string();
    
    let file_name = path
        .file_stem()
        .ok_or("No file stem")?
        .to_str()
        .ok_or("Invalid UTF-8 in filename")?;
    
    let category = path
        .parent()
        .and_then(|p| p.file_name())
        .and_then(|n| n.to_str())
        .ok_or("Cannot determine category")?;
    
    let name = match category {
        "solid" => format!("SOLID_{}", snake_case_to_upper(file_name)),
        "regular" => format!("REGULAR_{}", snake_case_to_upper(file_name)),
        "brands" => format!("BRAND_{}", snake_case_to_upper(file_name)),
        _ => snake_case_to_upper(file_name),
    };
    
    Ok(IconData {
        name,
        category: category.to_string(),
        view_box,
        path_data,
        comment,
        file_path: path.display().to_string(),
    })
}

fn process_icons_directory(dir: &Path) -> Vec<IconData> {
    let mut icons = Vec::new();
    
    for entry in WalkDir::new(dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().is_some_and(|ext| ext == "svg"))
    {
        match process_svg_file(entry.path()) {
            Ok(icon) => {
                icons.push(icon);
            }
            Err(e) => {
                eprintln!("Error processing {}: {}", entry.path().display(), e);
            }
        }
    }
    
    icons.sort_by(|a, b| a.name.cmp(&b.name));
    icons
}

fn generate_demo_module(icons: &[IconData]) -> String {
    let mut output = String::new();
    
    output.push_str(r#"//! All FontAwesome 7.0 icons for the demo
//! 
//! This module lists all available icons for the demo application.
//! Generated by icon-processor/src/bin/generate_demo_icons.rs

use yew_shortcuts::fontawesome::{Icon, icons};

"#);
    
    // Group icons by category
    let mut categories: BTreeMap<String, Vec<&IconData>> = BTreeMap::new();
    for icon in icons {
        categories
            .entry(icon.category.clone())
            .or_default()
            .push(icon);
    }
    
    // Generate arrays for each category
    for (category, category_icons) in categories {
        let array_name = match category.as_str() {
            "solid" => "SOLID_ICONS",
            "regular" => "REGULAR_ICONS",
            "brands" => "BRANDS_ICONS",
            _ => continue,
        };
        
        output.push_str(&format!(
            "pub const {}: &[(&str, &Icon)] = &[\n",
            array_name
        ));
        
        for icon in category_icons {
            // Remove category prefix from name for cleaner API
            let clean_name = icon.name
                .strip_prefix(&format!("{}_", category.to_uppercase()))
                .or_else(|| icon.name.strip_prefix(&"BRAND_".to_string()))
                .unwrap_or(&icon.name);
            
            let display_name = clean_name.replace('_', "-").to_lowercase();
            
            output.push_str(&format!(
                "    (\"{}\", &icons::{}::{}),\n",
                display_name,
                category,
                clean_name
            ));
        }
        
        output.push_str("];\n\n");
    }
    
    output
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let svg_dir = PathBuf::from("svgs-full-7");
    
    if !svg_dir.exists() {
        eprintln!("Error: svgs-full-7 directory not found!");
        eprintln!("Please ensure you're running this from the project root.");
        std::process::exit(1);
    }
    
    println!("Processing FontAwesome 7.0 icons for demo...");
    let icons = process_icons_directory(&svg_dir);
    
    println!("Processed {} icons total", icons.len());
    
    // Generate demo module
    println!("Generating demo module...");
    let demo_code = generate_demo_module(&icons);
    
    let output_path = PathBuf::from("demo/src/all_icons.rs");
    let mut file = fs::File::create(&output_path)?;
    file.write_all(demo_code.as_bytes())?;
    println!("Generated: {}", output_path.display());
    
    println!("\nDone! Use `cargo run --bin generate_demo_icons` to regenerate.");
    
    Ok(())
}